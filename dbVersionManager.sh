#!/usr/bin/env bash


# --------------------------------------------------------------
# This script aims to facilitate the implementation of a
# versioning system to any *SQL database.
# It is distributed under GNU GPLv3.0 License, if you add
# modification to this script feels free to open a pull request.
# See https://github.com/luannbertaud/SQL-DBVersionManager
# Script version: v1.3.0
# --------------------------------------------------------------




#
# Default parameters
#

DBname="";
DBhost="";
DBport="";
DBuser="";
DBpass="";
ConfFile="./dbVersionManager.conf";
DBInfoTable="db_info";
MigrationFolder="./dbMigrationScripts/";
MilestoneFolder="./dbMigrationScripts/";
ReverseMigrationFolder="./dbMigrationScripts/";
PassYes="No";
ByPassErrors="No";
TmpFolder=".";
Reverse="No";
ReverseVersion="";
MaxVersion="";
SafeMigration="No";
SafeMigrationVersion="";
OnlyScript="";
OnlyVersionMonitoring="No";

lastAppliedVers="No version applied";
actVer="unknown";
maxVer="unknown";
progName="$0";
sqlCli="mysql";
availableSQLCli=("mysql" "mysqlsh.exe" "psql")
versRegx='^[0-9]+(\.[0-9]+)*$';

printHelp() {
    echo -e "\nUsage: $progName [OPTIONS]\n"
    res=""
    res+="  -d,@--database@Name of the database to connect\n"
    res+="  -h,@--host@Server that host the database\n"
    res+="  -u,@--user@User for authentication on the sql server\n"
    res+="  -P,@--port@Port on the server where to access the database\n"
    res+="     @          @ Default is depending on --client\n"
    res+="  -c,@--config@Path to the configuration file from wich to load -d, -h, -u, -p\n"
    res+="     @          @ Default is [$ConfFile]\n"
    res+="  -r,@--reverse@Version to reset database to, scripts will be applied decreasingly\n"
    res+="  -v,@--version@Version to migrate the database to. By default all scripts are applied\n"
    res+="  -s,@--safe@Only apply migration scripts that have a matching reverse script before this version\n"
    res+="     @      @ After that version, regular migration will be applied\n"
    res+="  -p,@--password@Password for the user on the sql server\n"
    res+="     @          @ If not provided by command line, a prompt will ask for it\n"
    res+="  -t,@--infoTable@Name of the table in database that contain the version tracking column\n"
    res+="     @           @ Default is [$DBInfoTable]\n"
    res+="  -e,@--execute@Execute an sql script on the database, and nothing else\n"
    res+="  -M,@--migrationFolder@Path to the folder that contains migration scripts\n"
    res+="     @                 @ Default is [$MigrationFolder]\n"
    res+="  -R,@--reverseMigrationFolder@Path to the folder that contains reverse migration scripts\n"
    res+="     @                        @ Default is [$ReverseMigrationFolder]\n"
    res+="  -L,@--milestoneFolder@Path to the folder that contains milestone scripts\n"
    res+="     @                 @ Default is [$MilestoneFolder]\n"
    res+="     @--tmpFilesFolder@Path to the folder for temporary files generated by the script\n"
    res+="     @                @ Default is [$TmpFolder]\n"
    res+="     @--bypassErrors@Some errors can be bypassed by selecting this flag\n"
    res+="     @              @ A prompt will be displayed when bypass is available, be carreful.\n"
    res+="     @--versionMonitoringOnly@Only enabling version monitoring, no scripts applied\n"
    res+="     @              @ A prompt will be displayed when bypass is available, be carreful.\n"
    res+="     @--client@Use this flag to select the SQL client\n"
    res+="     @              @ Can be either: ($(echo ${availableSQLCli[*]})).\n"
    res+="     @              @ Default is [$sqlCli]\n"
    res+="  -y,@--yes@Do not display prompts, answer yes every time\n"
    echo -e "$res" | column -ts '@'

    res="Examples:\n"
    res+="  $progName -d myDB -h localhost -u root@Regular full migration all script applied\n"
    res+="  $progName -d myDB -h localhost -u root -v 2.5.16@All migration script applied to 2.5.16 inclusive\n"
    res+="  $progName -d myDB -h localhost -u root -r 2.5.10@Reset of the database using reverse scripts to v2.5.10\n"
    res+="  $progName -d myDB -h localhost -u root -s 2.5.13@Only scripts that have a matching reverse will be applied to 2.5.13 (inclusive)\n"
    res+="                                                  @ For version > 2.5.13, all scripts will be applied\n"
    res+="  $progName -d myDB -h localhost -u root --versionMonitoringOnly@No database migration, only verifications of the version monitoring system\n"
    echo
    echo -e "$res" | column -ts '@'

    echo
    echo "Versions and scripts:"
    echo "  There are 3 type of scripts:"
    echo "    - MIGRATION Apply some modifications to the database. Migration versions are increasing."
    echo "    - REVERSE   Revert some modifications of the database. After a revert the corresponding migration must be re-appliable."
    echo "    - MILESTONE Sums up previous migrations for newly created databases. A milestone creates a new empty fresh db scheme."
    echo
    echo "  You can define where to find different type of scripts using -M, -R, -L arguments, you can use the same folder as well."
    echo "  A script name must be defined as follow:"
    echo "    ->Its version corresponding to this regex: $versRegx"
    echo "    ->Its type preceded by a hyphen (nothing for migrations) eg. 2.5.11, 2.5.13-reverse, 2.5.10-milestone"
    echo "    ->Scripts are sorted using 'sort -V'"
    
}

#
# Read configuration file
#

setConfig=false
for arg in $@
do 
    if $setConfig; then ConfFile=$arg; break; fi
    if [ $arg = "-c" ] || [ $arg = "--config" ]; then setConfig=true; fi
done

if [[ -f $ConfFile ]];
then
    IFS="="
    while read -r key val;
    do
        if [ "$key" = "db.user" ]; then DBuser=$(echo $val | tr -d '"'); fi
        if [ "$key" = "db.password" ]; then DBpass=$(echo $val | tr -d '"'); fi
        if [ "$key" = "db.url" ];
        then
            DBhost=$(echo $val | tr -d '"' | cut -d / -f 3)
            DBname=$(echo $val | tr -d '"' | cut -d / -f 4 | cut -d ? -f 1)
        fi
        if [ "$key" = "db.host" ]; then DBhost=$(echo $val | tr -d '"'); fi
        if [ "$key" = "db.port" ]; then DBport=$(echo $val | tr -d '"'); fi
        if [ "$key" = "db.name" ]; then DBname=$(echo $val | tr -d '"'); fi
        if [ "$key" = "db.infoTable" ]; then DBInfoTable=$(echo $val | tr -d '"'); fi
        if [ "$key" = "migration.scripts" ]; then MigrationFolder=$(echo $val | tr -d '"'); fi
        if [ "$key" = "migration.reverseScripts" ]; then ReverseMigrationFolder=$(echo $val | tr -d '"'); fi
        if [ "$key" = "migration.milestones" ]; then MilestoneFolder=$(echo $val | tr -d '"'); fi
        if [ "$key" = "migration.client" ]; then sqlCli=$(echo $val | tr -d '"'); fi

    done < $ConfFile
fi
IFS=$'\n'

#
# Parsing parameters
#

while (( "$#" )); do
    case $1 in
        -d|--database) DBname="$2"; shift ;;
        -h|--host) DBhost="$2"; shift ;;
        -P|--port) DBport="$2"; shift ;;
        -u|--user) DBuser="$2"; shift ;;
        -c|--config) shift ;;
        -r|--reverse) ReverseVersion="$2"; Reverse="Yes"; shift ;;
        -v|--version) MaxVersion="$2"; shift ;;
        -p|--password) DBpass="$2"; shift ;;
        -t|--infoTable) DBInfoTable="$2"; shift ;;
        -e|--execute) OnlyScript="$2"; shift ;;
        -M|--migrationFolder) MigrationFolder="$2"; shift ;;
        -R|--reverseMigrationFolder) ReverseMigrationFolder="$2"; shift ;;
        -L|--milestoneFolder) MilestoneFolder="$2"; shift ;;
        --tmpFilesFolder) TmpFolder="$2"; shift ;;
        --bypassErrors) ByPassErrors="Yes" ;;
        -s|--safe) SafeMigration="Yes"; SafeMigrationVersion="$2"; shift ;;
        --versionMonitoringOnly) OnlyVersionMonitoring="Yes" ;;
        --client) sqlCli="$2"; shift ;;
        -y|--yes) PassYes="Yes" ;;
        --help) printHelp; exit 0 ;;
        *) echo "Unknown parameter : $1"; printHelp; exit 1 ;;
    esac
    shift
done

#
# Error handling on parameters
#

if [[ "$DBname" = "" || "$DBhost" = "" || "$DBuser" = "" ]];
then
    echo "Missing parameters to be able to connect the database."
    printHelp
    exit 1;
fi

if [ "$OnlyScript" = "" ] && [ "$OnlyVersionMonitoring" = "No" ];
then 
    if [[ ! -d $MigrationFolder || ! -d $ReverseMigrationFolder || ! -d $MilestoneFolder || ! -d $TmpFolder ]];
    then
        echo "Invalid folder path parameter."
        printHelp
        exit 1;
    fi

    if [ "$Reverse" = "Yes" ] && [ ! "$MaxVersion" = "" ];
    then
        echo "Incompatible parameters [--reverse & --version]."
        printHelp
        exit 1;
    fi

    if [ "$Reverse" = "Yes" ] && [ "$SafeMigration" = "Yes" ];
    then
        echo "Incompatible parameters [--reverse & --safe]."
        printHelp
        exit 1;
    fi

    if [ "$ByPassErrors" = "Yes" ] && [ "$PassYes" = "Yes" ];
    then
        echo "Incompatible parameters [--bypassErrors & --yes]. You must be carreful with bypassing errors."
        printHelp
        exit 1;
    fi
else
    if [ ! "$OnlyScript" = "" ] && [ "$OnlyVersionMonitoring" = "Yes" ];
    then
        echo "Incompatible parameters [--execute & --versionMonitoringOnly]."
        printHelp
        exit 1;
    fi

    if [ ! "$OnlyScript" = "" ] && [[ ! -f $OnlyScript ]];
    then
        echo "Invalid script path parameter."
        printHelp
        exit 1;
    fi

    if [ "$OnlyVersionMonitoring" = "Yes" ] && [ "$Reverse" = "Yes" ];
    then
        echo "Incompatible parameters [--versionMonitoringOnly & --reverse]."
        printHelp
        exit 1;
    fi

    if [ "$OnlyVersionMonitoring" = "Yes" ] && [ ! "$MaxVersion" = "" ];
    then
        echo "Incompatible parameters [--versionMonitoringOnly & --version]."
        printHelp
        exit 1;
    fi
fi

#
# Asking for database password if needed
#

if [[ "$DBpass" = "" ]];
then
    echo "Database password:";
    read -s -p "> " DBpass;
    
    for (( i=0; i<${#DBpass}; i++)) do echo -n "*"; done;
    echo
fi

#
# Sql client verification
#

if ! command -v $sqlCli &> /dev/null
then
    echo "ERROR Sql client [$sqlCli] could not be found, --client must be one of ($(echo ${availableSQLCli[*]})) and available on your computer."
    exit 1
fi

#
# Declaration of useful tools
#

if [ "$sqlCli" = "mysql" ];
then
    sqlParamsMin="-h $DBhost -u $DBuser --password=$DBpass";
    if [[ $DBport != '' ]]; then sqlParamsMin="$sqlParamsMin -P $DBport"; fi;
    sqlParams="$sqlParamsMin -N -D $DBname";
fi
if [ "$sqlCli" = "mysqlsh.exe" ];
then
    sqlParamsMin="-h $DBhost -u $DBuser --password=$DBpass";
    if [[ $DBport != '' ]]; then sqlParamsMin="$sqlParamsMin -P $DBport"; fi;
    sqlParams="$sqlParamsMin --save-passwords=never --sql -N -D $DBname";
fi
if [ "$sqlCli" = "psql" ];
then
    sqlParamsMin="-h $DBhost -U $DBuser";
    if [[ $DBport != '' ]]; then sqlParamsMin="$sqlParamsMin -p $DBport"; fi;
    export PGPASSWORD=$DBpass
    sqlParams="$sqlParamsMin -qt -d $DBname -c \"SET search_path = $DBname;\"";
fi

lastResult=$(mktemp $TmpFolder/.dbVersionManager.XXXXXXXXXXX.tmp)
migrationScripts=$(ls -p $MigrationFolder/ | grep -E "$versRegx" | sort -V)
milestoneScripts=$(ls -p $MilestoneFolder/ | grep -E "${versRegx:0:${#versRegx}-1}(\-milestone)$" | cut -d - -f 1 | sort -V)
reverseMigrationScripts=$(ls -p $ReverseMigrationFolder/ | grep -E "${versRegx:0:${#versRegx}-1}(\-reverse)$" | cut -d - -f 1 | sort -V -r)

exitClean() {
    rm $lastResult
    if (( $# > 0 ));
    then
        exit $1
    fi
    exit 0
}

verlte() {
    [  "$1" = "`echo -e "$1\n$2" | sort -V | head -n1`" ]
}

vergte() {
    [  "$1" = "`echo -e "$1\n$2" | sort -V | tail -n1`" ]
}

verlt() {
    [ "$1" = "$2" ] && return 1 || verlte $1 $2
}

vergt() {
    [ "$1" = "$2" ] && return 1 || vergte $1 $2
}

isClosest() {
    if [ "$1" = "$2" ];
    then
        return 0;
    fi
    lastOne="";
    for m in $migrationScripts;
    do
        if [ "$m" = "$1" ] || [ "$m" = "$2" ];
        then
            if [ "$lastOne" = "$1" ] || [ "$lastOne" = "$2" ];
            then
                return 0;
            fi
        fi
        lastOne=$m;
    done
    return 1;
}

runAndSave () {
    eval "$@" >$lastResult 2>&1
    return $?
}

execScript() { # TODO Generalize
    if [ ! "$sqlCli" = "mysql" ];
    then
        runAndSave "$sqlCli $sqlParams -f $1"
    else
        runAndSave "$sqlCli $sqlParams < $1"
    fi
}

execCmd() { # TODO Generalize
    if [ "$sqlCli" = "psql" ];
    then
        eval "$sqlCli $sqlParams -c \"$1\""
    else
        eval "$sqlCli $sqlParams -e \"$1\""
    fi
}

execCmdClean() { # TODO Generalize
    if [ "$sqlCli" = "psql" ];
    then
        runAndSave "$sqlCli $sqlParams -c \"$1\""
    else
        runAndSave "$sqlCli $sqlParams -e \"$1\""
    fi
}

execMinCmdClean() { # TODO Generalize
    if [ "$sqlCli" = "psql" ];
    then
        runAndSave "$sqlCli $sqlParamsMin -c \"$1\""
    else
        runAndSave "$sqlCli $sqlParamsMin -e \"$1\""
    fi
}

conditionalInput() {
    if [[ ! "$PassYes" = "Yes" ]];
    then
        echo "$@";
        read -p "> " uInput
    else
        uInput="Y"
    fi

    if [[ "$uInput" = "" ]];
    then
        echo -e "\033[1A\033[2K> Y"
    fi

    if [[ "$uInput" = "y" || "$uInput" = "" ]];
    then
        uInput="Y"
    fi
}

exitError() {

    if [ "$lastAppliedVers" = "$actVer" ];
    then
        lastAppliedVers="No version applied";
    fi
    if [ "$MaxVersion" = "" ];
    then
        MaxVersion="No max version";
    fi
    if [[ ! -f $ConfFile ]];
    then
        ConfFile="No"
    fi


    echo
    echo "=================================/!\================================="
    echo "Stopping migration due to an error:"
    if (( $# > 0 ));
    then
        echo -e "->$1"
    fi
    if [ ! "$(cat $lastResult)" = "" ];
    then
        echo -e "\n--------------------------------------------------------------------"
        sed -e "s/.\{68\}/&\n/g" < $lastResult
        echo -e "--------------------------------------------------------------------"
    fi
    echo -e "\nConfig:"
    echo -e "       Database name: $DBname"
    echo -e "       Database host: $DBhost"
    echo -e "       Database user: $DBuser"
    echo -e "  Configuration file: $ConfFile"
    echo -e "     Downgrading DB : $Reverse"
    echo -e "       Start version: $actVer"
    echo -e "      DB max version: $maxVer"
    echo -e "   Downgrade version: $ReverseVersion"
    echo -e "  Max version to set: $MaxVersion"
    echo -e "      Safe migration: $SafeMigration"
    echo -e "     Safe migrate to: $SafeMigrationVersion"
    echo -e "  Only v. monitoring: $OnlyVersionMonitoring"
    echo -e " Database info table: $DBInfoTable"
    echo -e "    Migration folder: $MigrationFolder"
    echo -e " Reverse Mig. folder: $ReverseMigrationFolder"
    echo -e "    Milestone folder: $MilestoneFolder"
    echo -e "Last applied version: $lastAppliedVers"
    echo -e " Allow bypass errors: $ByPassErrors"
    echo -e "Alway yes to prompts: $PassYes"
    echo "=================================/!\================================="
    
    if (( $# > 1 )) && [ "$ByPassErrors" = "Yes" ] ;
    then
        echo
        PassYes="No"
        conditionalInput "$2"
        if [ ! "$uInput" = "Y" ];
        then
            exitClean 1
        fi
        # Undo value cleaning
        if [ "$lastAppliedVers" = "No version applied" ];
        then
            lastAppliedVers="$actVer";
        fi
        if [ "$MaxVersion" = "No max version" ];
        then
            MaxVersion="";
        fi
    else
        exitClean 1
    fi
}

saveVersionInDb() {

    errorMsg="Unable to save version in database table [$DBInfoTable]."
    if [ ! "$3" = "" ];
    then
        errorMsg+="\n  WARNING: The script [$3] as been applied,\n  the version number in the database is now invalid. Please set it to $1."
    else
        erroMsg+=" Please set it to $1."
    fi

    if [ "$(execCmd "SELECT COUNT(version) FROM $DBInfoTable;" 2>/dev/null)" = "0" ] ;
    then
        sqlE=""
        if [ ! "$2" = "" ] && ( vergte "$1" "$2" );
        then
            sqlE="INSERT INTO $DBInfoTable (version, max_version) VALUES ('$1', '$1');"
        else
            sqlE="INSERT INTO $DBInfoTable (version) VALUES ('$1');"
        fi
        if ! execCmdClean "$sqlE"  ;
        then
            echo -e "\tKO"
            exitError "$errorMsg"
        fi
    else
        sqlE=""
        if [ ! "$2" = "" ] && ( vergte "$1" "$2" );
        then
            sqlE="UPDATE $DBInfoTable SET version = '$1', max_version = '$1';"
        else
            sqlE="UPDATE $DBInfoTable SET version = '$1';"
        fi
        if ! execCmdClean "$sqlE"  ;
        then
            echo -e "\tKO"
            exitError "$errorMsg"
        fi
    fi
}

#
# Prevent trailing files on ctrl_c 
#

trap exitClean SIGINT

#
# Testing server connection with credentials
#

echo -n "Checking sql server connection .."
if ! execMinCmdClean "SELECT version();" ;
then
    echo -e "\tKO"
    exitError "Error while connecting to sql server, please check credentials"
else
    echo -e "\tOK"
fi

#
# If in execute mode, we don't care about versions
#

if [ ! "$OnlyScript" = "" ];
then
    echo -n "Executing script [$OnlyScript] on $DBname .."
    if ! execScript $OnlyScript ;
    then
        echo -e "\tKO"
        exitError "Unable to apply script $OnlyScript"
    else
        echo -e "\tOK"
    fi
    exitClean
fi


#
# Error handling on reverse version
#

if [ "$Reverse" = "Yes" ];
then
    echo -n "Checking downgrade version validity .."
    if [[ ! $ReverseVersion =~ $versRegx ]] ;
    then
        echo -e "\tKO"
        echo "Provided downgrade version is invalid: [$ReverseVersion]"
        uInput=""
        while [[ ! $uInput =~ $versRegx ]];
        do
            echo "Please provide the version to downgrade the database to (eg. 2.108.89)";
            read -p "> " uInput
        done
        ReverseVersion=$uInput
    else
        echo -e "\tOK"
    fi
fi

#
# Error handling on max version
#

if [ ! "$MaxVersion" = "" ];
then
    echo -n "Checking max version validity .."
    if [[ ! $MaxVersion =~ $versRegx ]] ;
    then
        echo -e "\tKO"
        echo "Provided max version is invalid: [$MaxVersion]"
        uInput=""
        while [[ ! $uInput =~ $versRegx ]];
        do
            echo "Please provide the version to migrate the database to (eg. 2.108.89)";
            read -p "> " uInput
        done
        MaxVersion=$uInput
    else
        echo -e "\tOK"
    fi
fi

if [ "$OnlyVersionMonitoring" = "No" ];
then

    #
    # Error handling on migration folder and its scripts
    #

    echo -n "Checking migration versions validity .."
    for m in $(ls -p $MigrationFolder/ | grep -E -v "$versRegx");
    do
        if [[ $MigrationFolder = $MilestoneFolder && $m =~ ${versRegx:0:${#versRegx}-1}(\-milestone)$ ]];
        then
            continue
        fi 
        if [[ $MigrationFolder = $ReverseMigrationFolder && $m =~ ${versRegx:0:${#versRegx}-1}(\-reverse)$ ]];
        then
            continue
        fi 
        echo -e "\tKO"
        echo "Error verifying migration versions:" > $lastResult
        echo -e "  [$m] filename is not recognized as a migration version" >> $lastResult
        echo -e "  Regex for a migration version: $versRegx" >> $lastResult
        exitError "Invalid migration version"
    done
    echo -e "\tOK"
    if ! ls -p $MigrationFolder/ | grep -E "$versRegx" >/dev/null 2>&1 ;
    then
        echo "WARNING No migration script found in [$MigrationFolder]."
    fi

    #
    # Error handling on reverse folder and its scripts
    #

    echo -n "Checking reverse versions validity .."
    for m in $(ls -p $ReverseMigrationFolder/ | grep -E -v "${versRegx:0:${#versRegx}-1}(\-reverse)$");
    do
        if [[ $ReverseMigrationFolder = $MilestoneFolder && $m =~ ${versRegx:0:${#versRegx}-1}(\-milestone)$ ]];
        then
            continue
        fi 
        if [[ $ReverseMigrationFolder = $MigrationFolder && $m =~ $versRegx ]];
        then
            continue
        fi 
        echo -e "\tKO"
        echo "Error verifying reverse versions:" > $lastResult
        echo -e "  [$m] filename is not recognized as a reverse version" >> $lastResult
        echo -e "  Regex for a reverse version: ${versRegx:0:${#versRegx}-1}(\-reverse)$" >> $lastResult
        exitError "Invalid reverse version"
    done
    echo -e "\tOK"
    if ! ls -p $ReverseMigrationFolder/ | grep -E "${versRegx:0:${#versRegx}-1}(\-reverse)$" >/dev/null 2>&1 ;
    then
        echo "WARNING No reverse migration script found in [$ReverseMigrationFolder]."
    fi

    #
    # Error handling on milestone folder and its scripts
    #

    echo -n "Checking milestone versions validity .."
    for m in $(ls -p $MilestoneFolder/ | grep -E -v "${versRegx:0:${#versRegx}-1}(\-milestone)$");
    do
        if [[ $MilestoneFolder = $ReverseMigrationFolder && $m =~ ${versRegx:0:${#versRegx}-1}(\-reverse)$ ]];
        then
            continue
        fi 
        if [[ $MilestoneFolder = $MigrationFolder && $m =~ $versRegx ]];
        then
            continue
        fi 
        echo -e "\tKO"
        echo "Error verifying milestone versions:" > $lastResult
        echo -e "  [$m] filename is not recognized as a milestone version" >> $lastResult
        echo -e "  Regex for a milestone version: ${versRegx:0:${#versRegx}-1}(\-milestone)$" >> $lastResult
        exitError "Invalid milestone version"
    done
    echo -e "\tOK"
    if ! ls -p $MilestoneFolder/ | grep -E "${versRegx:0:${#versRegx}-1}(\-milestone)$" >/dev/null 2>&1 ;
    then
        echo "WARNING No milestone script found in [$MilestoneFolder]."
    fi

fi

#
# Connect or create the database
#

echo -en "Checking database status ..\t"
if ! execCmd "SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME = '$DBname';" 2>/dev/null | grep -q $DBname ;
then
    echo -e "\tKO"
    conditionalInput "Database $DBname does not exist yet on $DBhost, would you like to create it ? (Y/n)"
    if [[ "$uInput" = "Y" ]];
    then
        echo -n "Creating database $DBname on $DBhost .."
        if ! execMinCmdClean "CREATE DATABASE $DBname;" ;
        then
            echo -e "\tKO"
            exitError "Unable to create database" "Ignore critical error ? (Y/n)"
        elif [ "$OnlyVersionMonitoring" = "No" ];
        then
            if [[ "$sqlCli" = "psql" ]] && ! execCmdClean "ALTER SCHEMA public RENAME TO $DBname;";
            then
                echo -e "\tKO"
                exitError "Unable to rename public schema to $DBname" "Ignore critical error ? (Y/n)"
            fi
            echo -e "\tOK"

            m=$(echo "$milestoneScripts" | sort -V -r | tail -n1)
            if [ ! "$m" = "" ];
            then
                conditionalInput "Last milestone found is $m, would you like to populate database from it ? (Y/n)"
                if [[ "$uInput" = "Y" ]];
                then
                    echo -n "Populating database from $m milestone .."
                    if ! execScript "$MilestoneFolder/$m-milestone" ;
                    then
                        echo -e "\tKO"
                        exitError "Unable to apply script $m" "Ignore error ? (Y/n)"
                    else
                        if ! execCmd "SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = '$DBname' AND TABLE_NAME = '$DBInfoTable';" 2>/dev/null 2>&1 | grep -q "$DBInfoTable" ;
                        then
                            echo -e "\tOK"
                            echo "WARNING Fail to save milestone version automatically (No migration system on database)."
                        else
                            saveVersionInDb $m $m "$m-milestone"
                            echo -e "\tOK"
                        fi
                    fi
                else
                    echo "No milestone applied, database is empty."
                fi
            fi
        else
            if [[ "$sqlCli" = "psql" ]] && ! execCmdClean "ALTER SCHEMA public RENAME TO $DBname;";
            then
                echo -e "\tKO"
                exitError "Unable to rename public schema to $DBname" "Ignore critical error ? (Y/n)"
            fi
            echo -e "\tOK"
        fi
    else
        echo "Not creating database."
        exitClean
    fi
else
    echo -e "\tOK"
fi

#
# Connect, create or update version monitoring table on database
#

echo -n "Checking version monitoring system .."
if ! execCmd "SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = '$DBname' AND TABLE_NAME = '$DBInfoTable';" 2>/dev/null 2>&1 | grep -q "$DBInfoTable" ;
then
    echo -e "\tKO"

    conditionalInput "Version monitoring table $DBInfoTable does not exist yet, would you like to create it ? (Y/n)"
    if [[ "$uInput" = "Y" ]];
    then
        uInput=""
        while [[ ! $uInput =~ $versRegx ]];
        do
            echo "Please provide the current database version (eg. 2.108.89)";
            read -p "> " uInput
        done
        echo -n "Creating table $DBInfoTable in $DBname .."
        if ! execCmdClean "CREATE TABLE $DBInfoTable ( version VARCHAR(255) NOT NULL, max_version VARCHAR(255), PRIMARY KEY (version) ); INSERT INTO $DBInfoTable (version, max_version) VALUES ('$uInput', '$uInput');" ;
        then
            echo -e "\tKO"
            exitError "Unable to create table" "Ignore critical error ? (Y/n)"
        else
            actVer=$uInput
            maxVer=$uInput
            echo -e "\tOK"
        fi
    else
        echo "Not creating table."
        exitClean
    fi
else
    echo -e "\tOK"

    echo -n "Checking current version validity .."
    actVer=$(execCmd "SELECT version FROM $DBInfoTable;" 2>/dev/null | sed '/^[[:space:]]*$/d' | xargs echo | tail -n1)
    if [[ ! $actVer =~ $versRegx ]] ;
    then
        echo -e "\tKO"
        echo "Database current version is invalid or inexistent: [$actVer]"
        uInput=""
        while [[ ! $uInput =~ $versRegx ]];
        do
            echo "Please provide the current database version (eg. 2.108.89)";
            read -p "> " uInput
        done
        echo -n "Setting database version to $uInput .."
        saveVersionInDb $uInput
        actVer=$uInput
        echo -e "\tOK"
    else
        echo -e "\tOK"
    fi

    echo -en "Checking max version status ..\t"
    maxVer=$(execCmd "SELECT max_version FROM $DBInfoTable;" 2>/dev/null | sed '/^[[:space:]]*$/d' | xargs echo | tail -n1)
    if [[ $maxVer =~ $versRegx ]];
    then
        echo -e "\tOK"
        if ( vergt $maxVer $actVer ) && [ "$Reverse" = "No" ];
        then
            if [ "$SafeMigration" = "No" ] || ( vergt "$SafeMigrationVersion" "$maxVer" );
            then
                conditionalInput "The database has previously been downgraded, would you like to upgrade using --safe mode under $maxVer ? (Y/n)"
                if [[ "$uInput" = "Y" ]];
                then
                    SafeMigration="Yes"
                    SafeMigrationVersion=$maxVer
                fi
            fi
        fi
    else
        saveVersionInDb $actVer $actVer
        echo -e "\tOK"
    fi
fi

if [ "$OnlyVersionMonitoring" = "Yes" ];
then
    echo "Version monitoring system validated, $DBname is v$actVer."
    exitClean
fi

#
# Applying migration
#

migrationStarted=false
scripts=""
scriptsFolder=""
compFun=""
fileExt=""
if [ "$Reverse" = "Yes" ];
then
    scripts=$reverseMigrationScripts
    scriptsFolder=$ReverseMigrationFolder
    compFun=verlt
    fileExt="-reverse"
else
    scripts=$migrationScripts
    scriptsFolder=$MigrationFolder
    compFun=vergte
fi

if [ "$SafeMigration" = "Yes" ];
then
    echo "INFO Safe migration is activated, searching only for scripts that have a matching reverse."
fi

for m in $scripts;
do
    if [ "$Reverse" = "No" ] && [ "$(vergte $actVer $m ; echo $?)" = "0" ]; then continue; fi
    if [ "$Reverse" = "No" ] && [ ! "$MaxVersion" = "" ] && [ "$(vergt $m $MaxVersion ; echo $?)" = "0" ]; then break; fi
    if [ "$Reverse" = "No" ] && [ "$MaxVersion" = "$actVer" ]; then break; fi
    if [ "$Reverse" = "Yes" ] && [ "$(verlt $actVer $m ; echo $?)" = "0" ]; then continue; fi
    if [ "$Reverse" = "Yes" ] && [ "$(verlte $m $ReverseVersion; echo $?)" = "0" ]; then break; fi
    if [ "$Reverse" = "Yes" ] && [ "$ReverseVersion" = "$actVer" ]; then break; fi

    if [ "$SafeMigration" = "Yes" ];
    then
        if ( ! verlte $m $SafeMigrationVersion );
        then
            echo "INFO Safe migration version reached [$SafeMigrationVersion], disabling safe migration."
            SafeMigration="No"
        elif ( verlte $m $SafeMigrationVersion ) && ! ls -p $ReverseMigrationFolder/ | grep -E "^($m)(\-reverse)$" >/dev/null 2>&1;
        then
            continue
        fi
    fi

    if [ "$migrationStarted" = false ];
    then
        conditionalInput "Actual database version is $actVer, comfirm scripts application from $m ? (Y/n)"
        if [[ "$uInput" = "Y" ]];
        then
            migrationStarted=true
            lastAppliedVers=$actVer
        else
            echo "No script applied."
            exitClean
        fi
    fi

    if [ "$Reverse" = "No" ];
    then
        echo -n "Migrating from $lastAppliedVers to $m .."
    else
        echo -n "Reversing $m .."
    fi
    if ! execScript $scriptsFolder/$m$fileExt ;
    then
        savedErrMsg="$(cat $lastResult)"
        saveVersionInDb $lastAppliedVers $maxVer "$lastAppliedVers$fileExt"
        echo -e "\tKO"
        echo -e "$savedErrMsg" > $lastResult
        exitError "Unable to apply script $m" "Ignore error ? (Y/n)"
    else
        lastAppliedVers=$m
        echo -e "\tOK"
    fi
    
done

#
# Save state and cleanup
#

scriptMax=$(echo "$scripts" | tail -n1)
if [ ! "$MaxVersion" = "" ];
then
    if ( verlt $MaxVersion $scriptMax);
    then
        scriptMax=$MaxVersion
    fi
fi

if [ "$SafeMigration" = "Yes" ] && ( vergt $SafeMigrationVersion $actVer ) && [ ! "$actVer" = "$SafeMigrationVersion" ];
then
    if ( vergt $SafeMigrationVersion $scriptMax );
    then
        MaxVersion=$SafeMigrationVersion
        SafeMigrationVersion=$scriptMax
    fi
    if [ "$migrationStarted" = false ] && ( verlt $actVer $SafeMigrationVersion );
    then
        echo "No safe scripts founds."
    elif [ "$migrationStarted" = false ] && ( verlt $lastAppliedVers $SafeMigrationVersion );
    then
        echo "/!\ No safe scripts found to between $lastAppliedVers and $SafeMigrationVersion."
    fi
    migrationStarted=true
    lastAppliedVers=$SafeMigrationVersion
fi

if [ "$migrationStarted" = false ];
then
    echo "Database already up to date."
    if [ "$Reverse" = "Yes" ];
    then
        if ( vergt $actVer $ReverseVersion );
        then
            echo "/!\ Actual database version is $actVer but no migration scripts have been found to downgrade to $ReverseVersion."
        else
            echo "Its version is $actVer and you requested downgrade migration to v$ReverseVersion."
        fi
    elif [ ! "$scriptMax" = "" ];
    then
        if ( verlt $actVer $scriptMax );
        then
            echo "/!\ Actual database version is $actVer but no migration scripts have been found to migrate to $scriptMax."
        else
            echo "Its version is $actVer and highest applicable version is $scriptMax."
        fi
    fi
else
    if [ "$Reverse" = "Yes" ];
    then
        if ( ! isClosest $lastAppliedVers $ReverseVersion );
        then
            echo "/!\ No migration scripts found to downgrade database between $lastAppliedVers and $ReverseVersion."
        fi
        lastAppliedVers=$ReverseVersion
    fi
    if [ "$Reverse" = "No" ] && [ ! "$MaxVersion" = "" ] && [ ! "$lastAppliedVers" = "$MaxVersion" ];
    then
        echo "/!\ No migration scripts found to migrate database over $lastAppliedVers to $MaxVersion."
    fi
    echo -n "Setting database version to $lastAppliedVers .."    
    saveVersionInDb $lastAppliedVers $maxVer $lastAppliedVers
    echo -e "\tOK"
    echo "Database fully migrated to v$lastAppliedVers."
fi

exitClean